1.Bubble Sort
This sorting algorithm performs puts the largest/smallest number at its correct index in every comparison
by performing swaps in ever comparison.
Best Case: O(n)
Average Case: O(n^2)
Worst Case: O(n^2)

Insertion Sort
It takes each element from the input and finds the position it belongs in the sorted list and inserts it there.
Best Case: O(n)
Average Case: O(n^2)
Worst Case: O(n^2)

Quick Sort
This sorting algorithm uses. divide-and-conquer algorithm. It selects a 'pivot' element and
partitions the array into two sub-arrays, according to whether the elements are less than or greater than the pivot.
Best Case: O(n log n)
Average Case: O(n log n)
Worst Case: O(n^2)

Merge Sort
Merge Sort is a divide-and-conquer algorithm that divides the array into two halves, recursively
sorts them, and then merges the sorted halves.
Best Case: O(n log n)
Average Case: O(n log n)
Worst Case: O(n log n)

4.TC of Bubble Sort
Best Case: O(n)
This occurs when the array is already sorted.
Average Case: O(n^2)
Due to the nested loops iterating through the array.
Worst Case: O(n^2)
Occurs when the array is sorted in reverse order.

TC of Quick Sort
Best Case: O(n log n)
Occurs when the pivot divides the array into two equal halves.
Average Case: O(n log n)
Typical case for most pivot selections.
Worst Case: O(n^2)
Rare, occurs when the smallest or largest element is always chosen as the pivot.

Quick Sort has a better average time complexity (O(n log n)) compared to Bubble Sort (O(n^2)),
making it more efficient for large datasets.
